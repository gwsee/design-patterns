**原型**

```
原型是一种创建型设计模式， 使你能够复制对象， 甚至是复杂对象， 而又无需使代码依赖它们所属的类。

所有的原型类都必须有一个通用的接口， 使得即使在对象所属的具体类未知的情况下也能复制对象。 
原型对象可以生成自身的完整副本， 因为相同类的对象可以相互访问对方的私有成员变量。
```

**原型模式**
```
定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。

简单地理解，其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，
但是又不能直接使用，我会clone一个一毛一样的新对象来使用；基本上这就是原型模式。关键字：Clone。


```
**深拷贝和浅拷贝**
```

浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，
而引用类型，指向的还是原对象所指向的。

深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。
简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。
clone明显是深复制，clone出来的对象是是不能去影响原型对象的
```


##实现方式
```
创建原型接口， 并在其中声明 克隆方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。

原型类必须另行定义一个以该类对象为参数的构造函数。 
    构造函数必须复制参数对象中的所有成员变量值到新建实体中。 
    如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。

    如果编程语言不支持方法重载， 
    那么你可能需要定义一个特殊方法来复制对象数据。
    在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。

克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。
    注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 
    否则， 克隆方法可能会生成父类的对象。

你还可以创建一个中心化原型注册表， 用于存储常用原型。

    你可以新建一个工厂类来实现注册表， 
    或者在原型基类中添加一个获取原型的静态方法。 
    该方法必须能够根据客户端代码设定的条件进行搜索。 
    搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 
    找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。

    最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。
```
