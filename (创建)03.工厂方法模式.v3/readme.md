##工厂方法模式

```
是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
```


**简单工厂**
```
定义：定义了一个创建对象的类，由这个类来封装实例化对象的行为。

简单工厂存在的问题与解决方法： 
    简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，
    这违背了开闭原则，所以，从设计角度考虑，有一定的问题。
    
    如何解决？
    我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，
    这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
    这种方法也就是我们接下来要说的工厂方法模式。
```


**工厂方法**
```
定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

工厂方法存在的问题与解决方法：客户端需要创建类的具体的实例。

简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 
当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。

为了解决这一问题，我们可以把工厂类抽象为接口，
用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，
而不用根据产品去寻找不同的工厂，方便用户操作。
这也就是我们接下来要说的抽象工厂模式。
```
**抽象工厂**
```
定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类
```
##实现方式

```
让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。

在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。

在创建者代码中找到对于产品构造函数的所有引用。 
    将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。

    你可能需要在工厂方法中添加临时参数来控制返回的产品类型。

    工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 
        用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。

现在， 为工厂方法中的每种产品编写一个创建者子类， 
    然后在子类中重写工厂方法， 
    并将基本方法中的相关创建代码移动到工厂方法中。

如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。
    例如， 
        设想你有以下一些层次结构的类。 
        基类 邮件及其子类 航空邮件和 陆路邮件 ； ​ 运输及其子类 飞机, 卡车和 火车 。
         ​ 航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 
         你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 
         但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。

如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 
    如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。

```