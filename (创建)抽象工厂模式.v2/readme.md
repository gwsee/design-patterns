**简单工厂**
```
定义：定义了一个创建对象的类，由这个类来封装实例化对象的行为。

简单工厂存在的问题与解决方法： 
    简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，
    这违背了开闭原则，所以，从设计角度考虑，有一定的问题。
    
    如何解决？
    我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，
    这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
    这种方法也就是我们接下来要说的工厂方法模式。
```


**工厂方法**
```
定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

工厂方法存在的问题与解决方法：客户端需要创建类的具体的实例。

简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 
当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。

为了解决这一问题，我们可以把工厂类抽象为接口，
用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，
而不用根据产品去寻找不同的工厂，方便用户操作。
这也就是我们接下来要说的抽象工厂模式。
```
**抽象工厂**
```
定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类
```

##实现方式
```
以不同的产品类型与产品变体为维度绘制矩阵。

为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。

声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。

为每种产品变体实现一个具体工厂类。

在应用程序中开发初始化代码。 
    该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。
    然后将该工厂对象传递给所有需要创建产品的类。

找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。
```