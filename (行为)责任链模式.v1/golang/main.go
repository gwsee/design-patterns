package main

/**
声明处理者接口并描述请求处理方法的签名。
	确定客户端如何将请求数据传递给方法。
	最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。

为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。
	该类需要有一个成员变量来存储指向链上下个处理者的引用。
	你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变，
	则需要定义一个设定方法来修改引用成员变量的值。

	为了使用方便， 你还可以实现处理方法的默认行为。
	如果还有剩余对象， 该方法会将请求传递给下个对象。
	具体处理者还能够通过调用父对象的方法来使用这一行为。

依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：
	是否自行处理这个请求。
	是否将该请求沿着链进行传递。
客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。

客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。

由于链的动态性， 客户端需要准备好处理以下情况：
	链中可能只有单个链接。
	部分请求可能无法到达链尾。
	其他请求可能直到链尾都未被处理。
*/

/**
让我们来看看一个医院应用的责任链模式例子。 医院中会有多个部门， 如：
	前台
	医生
	药房
	收银
病人来访时， 他们首先都会去前台， 然后是看医生、 取药， 最后结账。
也就是说， 病人需要通过一条部门链， 每个部门都在完成其职能后将病人进一步沿着链条输送。

此模式适用于有多个候选选项处理相同请求的情形， 适用于不希望客户端选择接收者 （因为多个对象都可处理请求） 的情形，
还适用于想将客户端同接收者解耦时。 客户端只需要链中的首个元素即可。

正如示例中的医院， 患者在到达后首先去的就是前台。 然后根据患者的当前状态， 前台会将其指向链上的下一个处理者。
*/
func main() {

	cashier := &Cashier{}

	//Set next for medical department
	medical := &Medical{}
	medical.setNext(cashier)

	//Set next for doctor department
	doctor := &Doctor{}
	doctor.setNext(medical)

	//Set next for reception department
	reception := &Reception{}
	reception.setNext(doctor)

	patient := &Patient{name: "abc"}
	//Patient visiting
	reception.execute(patient)
}
